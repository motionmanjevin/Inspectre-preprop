{"version":3,"file":"pnpmNodeModulesCollector.js","sourceRoot":"","sources":["../../src/node-module-collector/pnpmNodeModulesCollector.ts"],"names":[],"mappings":"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","sourcesContent":["import { isEmptyOrSpaces, log } from \"builder-util\"\nimport * as path from \"path\"\nimport { NodeModulesCollector } from \"./nodeModulesCollector\"\nimport { PM } from \"./packageManager\"\nimport { PnpmDependency } from \"./types\"\n\nexport class PnpmNodeModulesCollector extends NodeModulesCollector<PnpmDependency, PnpmDependency> {\n  public readonly installOptions = {\n    manager: PM.PNPM,\n    lockfile: \"pnpm-lock.yaml\",\n  }\n\n  protected getArgs(): string[] {\n    return [\"list\", \"--prod\", \"--json\", \"--depth\", \"Infinity\"]\n  }\n\n  private async getProductionDependencies(depTree: PnpmDependency): Promise<{ path: string; dependencies: Record<string, string>; optionalDependencies: Record<string, string> }> {\n    const packageName = depTree.name || depTree.from\n    if (isEmptyOrSpaces(packageName)) {\n      log.error(depTree, `Cannot determine production dependencies for package with empty name`)\n      throw new Error(`Cannot compute production dependencies for package with empty name: ${packageName}`)\n    }\n\n    const result = await this.cache.locatePackageVersion({ parentDir: depTree.path, pkgName: packageName, requiredRange: depTree.version })\n    if (result == null) {\n      return { path: path.resolve(depTree.path), dependencies: {}, optionalDependencies: {} }\n    }\n\n    const { dependencies, optionalDependencies } = result.packageJson\n    return { path: result.packageDir, dependencies: { ...dependencies }, optionalDependencies: { ...optionalDependencies } }\n  }\n\n  protected async extractProductionDependencyGraph(tree: PnpmDependency, dependencyId: string) {\n    if (this.productionGraph[dependencyId]) {\n      return\n    }\n    this.productionGraph[dependencyId] = { dependencies: [] }\n\n    const packageName = tree.name || tree.from\n\n    const treeDep = { ...(tree.dependencies || {}), ...(tree.optionalDependencies || {}) }\n    const json = packageName === dependencyId ? null : await this.getProductionDependencies(tree)\n    const prodDependencies = json ? { ...json.dependencies, ...json.optionalDependencies } : treeDep\n\n    const collectedDependencies: string[] = []\n    for (const packageName in treeDep) {\n      if (!prodDependencies[packageName]) {\n        continue\n      }\n\n      // Then check if optional dependency path exists (using actual resolved path)\n      const version = json?.optionalDependencies?.[packageName] || tree.optionalDependencies?.[packageName]?.version || \"\"\n      const result = await this.locatePackageWithVersion({ name: packageName, version, path: json?.path ?? tree.path })\n      if (result == null || !(await this.cache.exists[result.packageDir])) {\n        log.debug({ packageName, version: version, searchPath: result?.packageDir }, `optional dependency not installed, skipping`)\n        continue\n      }\n      const dependency = treeDep[packageName]\n      const childDependencyId = this.packageVersionString(dependency)\n      await this.extractProductionDependencyGraph(dependency, childDependencyId)\n      collectedDependencies.push(childDependencyId)\n    }\n    this.productionGraph[dependencyId] = { dependencies: collectedDependencies }\n  }\n\n  protected async collectAllDependencies(tree: PnpmDependency) {\n    // Collect regular dependencies\n    for (const [key, value] of Object.entries(tree.dependencies || {})) {\n      const json = await this.getProductionDependencies({ ...value, name: key })\n      this.allDependencies.set(`${key}@${value.version}`, { ...value, path: json.path })\n      await this.collectAllDependencies(value)\n    }\n\n    // Collect optional dependencies if they exist\n    for (const [key, value] of Object.entries(tree.optionalDependencies || {})) {\n      const json = await this.getProductionDependencies(value)\n      this.allDependencies.set(`${key}@${value.version}`, { ...value, path: json.path })\n      await this.collectAllDependencies(value)\n    }\n  }\n\n  protected packageVersionString(pkg: PnpmDependency): string {\n    // we use 'from' field because 'name' may be different in case of aliases\n    return `${pkg.from}@${pkg.version}`\n  }\n\n  protected parseDependenciesTree(jsonBlob: string): PnpmDependency {\n    // pnpm returns an array of dependency trees\n    const dependencyTree: PnpmDependency[] = this.extractJsonFromPollutedOutput<PnpmDependency[]>(jsonBlob)\n    return dependencyTree[0]\n  }\n}\n"]}